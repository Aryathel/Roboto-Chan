# Roboto-Chan:
WIP Robot Stuff - Python Script From Raspberry Pi 2b interacting with Arduino Nano to operate the MeArmV0.4

The coding for this project is written entirely from scratch by me, HeroicosHM, and my partner Aurorans Solis.
The goal of this project is an easy to use, simple GUI which any user can have fun controlling a robotic arm with.

# General Info:

We used a Raspberry Pi 2b, running NOOBS - Raspbian, in combination with an Arduino Nano, ATmega328P, connected through Serial cable.
On the Raspberry pi, the RobotGUI.py python script runs, generating a GUI intended for controlling the arm.
  - We used the Tkinter module in python to actually make the GUI.
  - For reading and writing from the Serial port, we used the pySerial module.
On the Arduino is all of the code which writes serial data to be read by the python code and displayed for the user to see,
and also the code which reads the return data generated by user input in order to move the arm.

All credit for the design of the arm itself goes to Mime Industries' MeArmV0.4.
https://shop.mime.co.uk/products/mearm-pocket-sized-robot-arm

We used the Corel Draw file (located at https://www.thingiverse.com/thing:360108)
to laser cut the pieces for the arm out of simple plywood that had been planed down to around 1.3" thick.

The servos we used are standard hobby servos.

# Project Logs:

In order for our particular design to work we needed to be able
to read the actual position of the servo, not just perform a servo.read() command on the Arduino
(this return the last value that was written, not tha actual current position of the servo).
To solve this problem, we took apart our servos and poked around with a multi-meter until we found  pin that changed voltage
depending on the position of the servo. After soldering a wire to this pin, we were able to map the values read from the pin
and read the angle of the servo in real time.

From here we began to write the data which the Arduino was reading to a very simple Python script, which accepts
the numbers and displays them on the GUI in reaction to a button press.

A lot of time was spent learning the Tkinter functions and how to organize a GUI, as well as how to perform specific actions,
like a dynamically updating label system which gives you a live readout of the angles of the servos.

Auro began taking measurements and doing the math for Cartesian movements at this point,
and although those have not yet been implemented, they should be soon.

We spent the majority of two weeks at this point debugging and trying to solve various problems, sually ending up
with an  extremely simple solution that made us feel silly.

Examples of Solved Issues:
  - Problem: The read command in our Python was not updating its data when it was called, so we could not read the data real time.
    - Solution: When the arduino does Serial.print(), it adds that to a buffer, a long list of things, and when the Python
          code calls the next things in the buffer. Basically we were filling the buffer up way faster than we could
          ever empty it. So we only ever had the arduino print something when the python sode calls for it to be printed,
          and it only prints once then gets read immediately, removing it from the buffer.
          
  - Problem: When we called the updateData() function, the arduino sent the data, but for some reason the python script could not
        use it.
    - Solution: It turns out theat the variable that was being created in the function basically ceased to exist as soon as
          the function ended. This was solved by adding "global entries" 
          (entries being the variable that needed to be read by other functions)  in order to make the entries variable useable.
          
  - Problem: The loop which updates the dynamic labels on the GUI so that the user can constantly see live servo position was
        making it so that the other buttons were not able to run, or so it seemed.
    - Solution: As it so happens, the problem here was that the python code was writing multiple things to the arduino
          at once, once again overfilling the buffer and putting data in the wrong order to be read properly. This was
          being cause by a couple of time.sleep() functions, equivalent of delay() functions on Arduino.
          
  - Problem: The updateData() function was alternating in its outputs between the string "Please Input A Command:" and the
        actual data we wanted, so it took twice as long to update the servo positions.
    - Solution: This took way too long to solve, and this one definitely makes me feel dumb. At the beginning of every loop
          on the arduino, it waits for user input. Originally, right before waiting for user input, it would
          Serial.print("Please Enter A Command:"), to give the serial monitor actual meaning when looking at it.
          However, as we eventually realized, this also added the string to the buffer mentioned earlier, which means that
          when data was read it read the string as well. We simply toook out that print function to fix this.
          
  - Problem: The Serial.readLine() functions on the Arduino is incredibly slow, taking around 2.5 seconds to run.
        This means it would be nearly impossible to run a smooth user interface using this method.
    - Solution: Instead of Serial.readLine(), you can use Serial.read(). This reads the written thing in byte format,
          but only the first digit. We manipulated this and monkeyed with it until eventually everything came together,
          and runs quite quickly as well.
          
  - Problem: The Arm would slowly degrade how consistant it's movements would be, eventually to the point where the arm 
	would only twitch, not move as it should.
    - Solution: As it turns out the problem was with the voltage output from the battery decreasing. The way our 
	  servos get read is from the voltage that runs through them, which varies based on the angle of the servo, and 
	  also from the amount of voltage that actually gets fed through it. We solved this by adding several movements 
	  in the ``void setup()`` on the Arduino to calibrate exactly what voltage readings it is meant to be using. It 
	  runs this calibration whenever a serial connection is opened or closed, assuring that unless you are using the 
	  arm over long periods of time, the movements will always be accurate. Eventually we hope to have an adapter 
	  hooked in to this design from a consistant power source.

  - Problem: The Left servo has a varying range of movement, which depends on the location of the Right servo at any 
	given time. We did not know how to account for this movements in the code to protect the user from accidentally 
	going out of range and damaging something.
    - Solution: Hero was able to create a map function that runs in Python exactly the same as the Arduino, and we used
	  this to dynamically read the Right servo location and map that number through Right servo's range, and the Left 
	  servo's range, and this resulted in getting our maximums and minimum for the Left servo at any given time. 
	  This was implemented in the GUI as a label next to the user entry fields which tell you what value you can use, 
	  and as a pop up notification if the user ever goes out of bounds.

# Miscellanious:

This project was created for our high school engineering class, who provided almost all of the materials for us,
including but not limited to the Raspberry Pi, Arduino, Servos, Breadboard, Wiring, and wood and laser cutters for said wood.
    
Originally the plan for this arm was to build the GUI and then move on the building a NEAT AI to control the arm
using image recognition to learn how to accomplish simple asks. This ideawas scrapped when looking at our time frame
for the project, but we hope to maybe revisit it one day.
    
Thank You for checking out Roboto-Chan!

  If you have any questions my email is houghtonawe@gmail.com.
  
- HeroicosHM
